(sort lclock)
(sort index)
(fun |<:index:index| (->  index indexBool))
(fun |<:lclock:lclock| (->  lclock lclockBool))
(fun |index.succ| (->  index indexBool))
(fun |lclock.succ| (->  lclock lclockBool))
(state-var .q Bool :next new_.q)
(state-var .r Bool :next new_.r)
(state-var m.begun1 (Array lclock Bool) :next new_m.begun1)
(state-var m.begun2 (Array lclock Bool) :next new_m.begun2)
(state-var m.done1 (Array lclock Bool) :next new_m.done1)
(state-var m.done2 (Array lclock Bool) :next new_m.done2)
(state-var m.trying1 Bool :next new_m.trying1)
(state-var m.trying2 Bool :next new_m.trying2)
(transition-var __m_.r Bool)
(transition-var __m_.r_a Bool)
(transition-var __m_m.trying1 Bool)
(transition-var __m_m.trying2 Bool)
(transition-var __ts0_a Bool)
(transition-var __ts0_b Bool)
(transition-var |__fml:lt| lclock)
(transition-var |__loc:x| lclock)
(var |0:index| index)
(var |0:lclock| lclock)
(init (and (not .r)
     (not .q)
     (= m.begun1 ((as const (Array lclock Bool)) false))
     (= m.done1 ((as const (Array lclock Bool)) false))
     (= m.begun2 ((as const (Array lclock Bool)) false))
     (= m.done2 ((as const (Array lclock Bool)) false))
     (not m.trying1)
     (not m.trying2)))
(transition (and (not new_.r)
     (not new_.q)
     (= m.begun2 new_m.begun2)
     (= m.trying1 new_m.trying1)
     (= m.done1 new_m.done1)
     (= m.trying2 new_m.trying2)
     (= m.done2 new_m.done2)
     (= m.begun1 new_m.begun1)) :name _idle)
(transition (let ((a!1 (forall ((|X:lclock| lclock))
             (or (not (select m.done1 |X:lclock|)) (select m.begun2 |X:lclock|))))
      (a!2 (forall ((|X:lclock| lclock))
             (or (not (select m.done1 |X:lclock|)) (select m.begun1 |X:lclock|))))
      (a!3 (forall ((|X:lclock| lclock))
             (or (not (select m.begun2 |X:lclock|)) (select m.done1 |X:lclock|))))
      (a!4 (forall ((|X:lclock| lclock))
             (or (not (select new_m.done1 |X:lclock|))
                 (select new_m.begun2 |X:lclock|))))
      (a!5 (forall ((|X:lclock| lclock))
             (or (not (select new_m.done1 |X:lclock|))
                 (select m.begun1 |X:lclock|))))
      (a!6 (forall ((|X:lclock| lclock))
             (or (not (select new_m.begun2 |X:lclock|))
                 (select new_m.done1 |X:lclock|)))))
  (and (not __m_.r_a)
       (not new_.q)
       __m_m.trying1
       (= __m_.r (or __m_.r_a __m_m.trying1))
       (not new_m.trying1)
       (= new_.r (or __m_.r new_m.trying1))
       (= new_m.done1 (ite __ts0_b m.done1 (store m.done1 |__loc:x| true)))
       (= new_m.begun2 (ite __ts0_b m.begun2 (store m.begun2 |__loc:x| true)))
       (= m.trying2 new_m.trying2)
       (= m.done2 new_m.done2)
       (= m.begun1 new_m.begun1)
       a!1
       a!2
       (not m.trying1)
       (not m.trying2)
       a!3
       (or __ts0_a __ts0_b)
       (or (not __ts0_a) (select m.begun1 |__loc:x|))
       (or (not __ts0_a) (not (select m.done1 |__loc:x|)))
       (forall ((|V0:lclock| lclock))
         (let ((a!1 (not (and (select m.begun1 |V0:lclock|)
                              (not (select m.done1 |V0:lclock|))
                              (or (= |V0:lclock| |__loc:x|)
                                  (|<:lclock:lclock| |V0:lclock| |__loc:x|))
                              (not (= |V0:lclock| |__loc:x|))))))
           (or (not __ts0_a) a!1)))
       (forall ((|V0:lclock| lclock))
         (let ((a!1 (not (and (select m.begun1 |V0:lclock|)
                              (not (select m.done1 |V0:lclock|))))))
           (or (not __ts0_b) a!1)))
       a!4
       a!5
       a!6)) :name m.recv1)
(transition (let ((a!1 (forall ((|X:lclock| lclock))
             (or (not (select m.done1 |X:lclock|)) (select m.begun2 |X:lclock|))))
      (a!2 (forall ((|X:lclock| lclock))
             (or (not (select m.done1 |X:lclock|)) (select m.begun1 |X:lclock|))))
      (a!3 (forall ((|X:lclock| lclock))
             (or (not (select m.begun2 |X:lclock|)) (select m.done1 |X:lclock|)))))
  (and (not new_.r)
       (not new_.q)
       __m_m.trying2
       (not new_m.trying2)
       (= new_m.done2 (ite __ts0_b m.done2 (store m.done2 |__loc:x| true)))
       (= m.begun2 new_m.begun2)
       (= m.trying1 new_m.trying1)
       (= m.done1 new_m.done1)
       (= m.begun1 new_m.begun1)
       a!1
       a!2
       (not m.trying1)
       (not m.trying2)
       a!3
       (or __ts0_a __ts0_b)
       (or (not __ts0_a) (select m.begun2 |__loc:x|))
       (or (not __ts0_a) (not (select m.done2 |__loc:x|)))
       (forall ((|V0:lclock| lclock))
         (let ((a!1 (not (and (select m.begun2 |V0:lclock|)
                              (not (select m.done2 |V0:lclock|))
                              (or (= |V0:lclock| |__loc:x|)
                                  (|<:lclock:lclock| |V0:lclock| |__loc:x|))
                              (not (= |V0:lclock| |__loc:x|))))))
           (or (not __ts0_a) a!1)))
       (forall ((|V0:lclock| lclock))
         (let ((a!1 (not (and (select m.begun2 |V0:lclock|)
                              (not (select m.done2 |V0:lclock|))))))
           (or (not __ts0_b) a!1))))) :name m.recv2)
(transition (let ((a!1 (forall ((|X:lclock| lclock))
             (or (not (select m.done1 |X:lclock|)) (select m.begun2 |X:lclock|))))
      (a!2 (forall ((|X:lclock| lclock))
             (or (not (select m.done1 |X:lclock|)) (select m.begun1 |X:lclock|))))
      (a!3 (forall ((|X:lclock| lclock))
             (or (not (select m.begun2 |X:lclock|)) (select m.done1 |X:lclock|))))
      (a!4 (forall ((|X:lclock| lclock))
             (or (not (select m.begun1 |X:lclock|))
                 (|<:lclock:lclock| |X:lclock| |__fml:lt|))))
      (a!5 (forall ((|X:lclock| lclock))
             (or (not (select m.done1 |X:lclock|))
                 (select new_m.begun1 |X:lclock|)))))
  (and (not new_.r)
       (not new_.q)
       (= new_m.begun1 (store m.begun1 |__fml:lt| true))
       (= m.begun2 new_m.begun2)
       (= m.trying1 new_m.trying1)
       (= m.done1 new_m.done1)
       (= m.trying2 new_m.trying2)
       (= m.done2 new_m.done2)
       a!1
       a!2
       (not m.trying1)
       (not m.trying2)
       a!3
       a!4
       a!5)) :name m.send1)
(theory-axiom (forall ((|X:index| index) (|Y:index| index) (|Z:index| index))
  (let ((a!1 (and (|<:index:index| |X:index| |Z:index|)
                  (not (and (|<:index:index| |X:index| |Y:index|)
                            (|<:index:index| |Y:index| |Z:index|))))))
    (or (not (index.succ |X:index| |Z:index|)) a!1)))
(theory-axiom (forall ((|T:index| index) (|U:index| index) (|V:index| index))
  (or (not (and (|<:index:index| |T:index| |U:index|)
                (|<:index:index| |U:index| |V:index|)))
      (|<:index:index| |T:index| |V:index|)))
(theory-axiom (forall ((|T:index| index) (|U:index| index))
  (not (and (|<:index:index| |T:index| |U:index|)
            (|<:index:index| |U:index| |T:index|))))
(theory-axiom (forall ((|T:index| index) (|U:index| index))
  (or (|<:index:index| |T:index| |U:index|)
      (= |T:index| |U:index|)
      (|<:index:index| |U:index| |T:index|)))
(theory-axiom (forall ((|X:index| index))
  (or (= |0:index| |X:index|) (|<:index:index| |0:index| |X:index|)))
(theory-axiom (forall ((|X:lclock| lclock) (|Y:lclock| lclock) (|Z:lclock| lclock))
  (let ((a!1 (and (|<:lclock:lclock| |X:lclock| |Z:lclock|)
                  (not (and (|<:lclock:lclock| |X:lclock| |Y:lclock|)
                            (|<:lclock:lclock| |Y:lclock| |Z:lclock|))))))
    (or (not (lclock.succ |X:lclock| |Z:lclock|)) a!1)))
(theory-axiom (forall ((|T:lclock| lclock) (|U:lclock| lclock) (|V:lclock| lclock))
  (or (not (and (|<:lclock:lclock| |T:lclock| |U:lclock|)
                (|<:lclock:lclock| |U:lclock| |V:lclock|)))
      (|<:lclock:lclock| |T:lclock| |V:lclock|)))
(theory-axiom (forall ((|T:lclock| lclock) (|U:lclock| lclock))
  (not (and (|<:lclock:lclock| |T:lclock| |U:lclock|)
            (|<:lclock:lclock| |U:lclock| |T:lclock|))))
(theory-axiom (forall ((|T:lclock| lclock) (|U:lclock| lclock))
  (or (|<:lclock:lclock| |T:lclock| |U:lclock|)
      (= |T:lclock| |U:lclock|)
      (|<:lclock:lclock| |U:lclock| |T:lclock|)))
(theory-axiom (forall ((|X:lclock| lclock))
  (or (= |0:lclock| |X:lclock|) (|<:lclock:lclock| |0:lclock| |X:lclock|)))
(live-assumption (m.begun1 _X) :name live0)
(live-property (m.done2 _X) :name live0)
(fair-assumption .r :name live0)